(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"));
	else if(typeof define === 'function' && define.amd)
		define(["jQuery"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("jQuery")) : factory(root["jQuery"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_15__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AttributeSlicer_1 = __webpack_require__(8);\n/**\n * Implements a free text search\n */\nvar FreeTextSearch = (function (_super) {\n    __extends(FreeTextSearch, _super);\n    /**\n     * Constructor for the free text search\n     */\n    function FreeTextSearch(element, provider) {\n        var _this = this;\n        _super.call(this, element);\n        /**\n         * The skip amount\n         */\n        this.skip = FreeTextSearch.DEFAULT_SKIP_AMOUNT;\n        this.serverSideSearch = true;\n        this.events.on(\"canLoadMoreData\", function (item, isSearch) {\n            item.result = isSearch || (typeof _this.offset === 'undefined' || typeof _this.total === 'undefined' || (_this.offset + _this.skip) < _this.total);\n        });\n        this.events.on(\"loadMoreData\", function (item, isNewSearch) {\n            if (isNewSearch) {\n                _this.offset = _this.skip * -1; // Negate this so we don't add it, and start over\n                _this.total = undefined;\n            }\n            item.result = _this.loadData((_this.offset || 0) + _this.skip);\n        });\n        this.searchProvider = provider;\n        this.showHighlight = true;\n    }\n    Object.defineProperty(FreeTextSearch.prototype, \"searchProvider\", {\n        get: function () {\n            return this._searchProvider;\n        },\n        /**\n         * Setter for the search provider\n         */\n        set: function (provider) {\n            var _this = this;\n            this._searchProvider = provider;\n            this.offset = undefined;\n            this.total = undefined;\n            this.data = [];\n            if (provider) {\n                this.loadingMoreData = true;\n                this.loadData(0).then(function (n) {\n                    _this.data = n;\n                    _this.loadingMoreData = false;\n                    setTimeout(function () { return _this.checkLoadMoreData(); }, 10);\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Loads the data from the services\n     */\n    FreeTextSearch.prototype.loadData = function (offset) {\n        var _this = this;\n        this.offset = undefined;\n        this.total = undefined;\n        var query = this.buildQuery(this.searchString);\n        return this.searchProvider.query({\n            offset: offset || 0,\n            count: this.skip,\n            query: query\n        }).then(function (results) {\n            _this.offset = results.offset;\n            _this.total = results.total;\n            return results.results.map(function (d) {\n                var textResult = d.textualMatch;\n                var searchString = _this.searchString;\n                if (_this.searchString) {\n                    var cols = Object.keys(query.where.eq);\n                    searchString = query.where.eq[cols[0]];\n                }\n                searchString = searchString.replace(/\\\"/g, \"\");\n                var idx = textResult.search(new RegExp(searchString, \"i\"));\n                var match = textResult;\n                var prefix = \"\";\n                var suffix = \"\";\n                if (searchString && idx >= 0) {\n                    var firstIdx = Math.max(0, idx - Math.ceil(searchString.length / 2));\n                    prefix = match.substring(firstIdx, idx);\n                    suffix = match.substring(idx + searchString.length, idx + searchString.length + Math.ceil(searchString.length / 2));\n                    match = match.substring(idx, idx + searchString.length);\n                }\n                else {\n                    suffix = match.substring(0, 30);\n                    match = \"\";\n                }\n                var item = {\n                    id: d.id,\n                    match: match,\n                    matchPrefix: prefix,\n                    matchSuffix: suffix,\n                    selected: false,\n                    value: 0,\n                    renderedValue: undefined,\n                    equals: function (b) { return d.id === b.id; }\n                };\n                return item;\n            });\n        });\n    };\n    /**\n     * Builds the query\n     */\n    FreeTextSearch.prototype.buildQuery = function (searchText) {\n        var column = \"*\";\n        // If searchString looks like \"emailId::5432\", then use everything before it as a column search\n        if (searchText) {\n            var parts = searchText.split(\"::\");\n            if (parts.length === 2) {\n                column = parts[0];\n                searchText = parts[1];\n            }\n        }\n        searchText = searchText || \"*\";\n        return {\n            where: {\n                eq: (_a = {},\n                    _a[column] = searchText,\n                    _a\n                )\n            }\n        };\n        var _a;\n    };\n    /**\n     * The default skip amount for free text search\n     */\n    FreeTextSearch.DEFAULT_SKIP_AMOUNT = 100;\n    /**\n     * A static list of providers\n     */\n    FreeTextSearch.DEFAULT_PROVIDERS = __webpack_require__(5);\n    return FreeTextSearch;\n}(AttributeSlicer_1.AttributeSlicer));\nexports.FreeTextSearch = FreeTextSearch;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/freetext/FreeTextSearch.ts\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/freetext/FreeTextSearch.ts?");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\n'use strict';\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/process/browser.js?");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\r\n * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license\r\n * Author: Jim Palmer (based on chunking idea from Dave Koelle)\r\n */\n/*jshint unused:false */\n'use strict';\n\nmodule.exports = function naturalSort(a, b) {\n\t\"use strict\";\n\tvar re = /(^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?$|^0x[0-9a-f]+$|\\d+)/gi,\n\t    sre = /(^[ ]*|[ ]*$)/g,\n\t    dre = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[\\/\\-]\\d{1,4}[\\/\\-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/,\n\t    hre = /^0x[0-9a-f]+$/i,\n\t    ore = /^0/,\n\t    i = function i(s) {\n\t\treturn naturalSort.insensitive && ('' + s).toLowerCase() || '' + s;\n\t},\n\t   \n\t// convert all to strings strip whitespace\n\tx = i(a).replace(sre, '') || '',\n\t    y = i(b).replace(sre, '') || '',\n\t   \n\t// chunk/tokenize\n\txN = x.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\n\t    yN = y.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\n\t   \n\t// numeric, hex or date detection\n\txD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x),\n\t    yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,\n\t    oFxNcL,\n\t    oFyNcL;\n\t// first try and sort Hex codes or Dates\n\tif (yD) {\n\t\tif (xD < yD) {\n\t\t\treturn -1;\n\t\t} else if (xD > yD) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\t// natural sorting through split numeric strings and default strings\n\tfor (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {\n\t\t// find floats not starting with '0', string or 0 if not defined (Clint Priest)\n\t\toFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;\n\t\toFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;\n\t\t// handle numeric vs string comparison - number < string - (Kyle Adams)\n\t\tif (isNaN(oFxNcL) !== isNaN(oFyNcL)) {\n\t\t\treturn isNaN(oFxNcL) ? 1 : -1;\n\t\t}\n\t\t// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'\n\t\telse if (typeof oFxNcL !== typeof oFyNcL) {\n\t\t\t\toFxNcL += '';\n\t\t\t\toFyNcL += '';\n\t\t\t}\n\t\tif (oFxNcL < oFyNcL) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (oFxNcL > oFyNcL) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/javascript-natural-sort/naturalSort.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/javascript-natural-sort/naturalSort.js?");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tmodule.children = [];\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\n'use strict';\n\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function splitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n// path.relative(from, to)\n// posix version\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nexports.basename = function (path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  return splitPath(path)[3];\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/path-browserify/index.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar req = __webpack_require__(14);\nvar reqs = {};\nvar path = __webpack_require__(4);\nreq.keys().forEach(function (key) {\n    var providerName = path.basename(key, '.ts');\n    if (providerName[0] !== 'I') {\n        var required = req(key);\n        var provider = required['default'] || required[providerName];\n        if (provider) {\n            reqs[provider.name] = provider;\n        }\n    }\n});\nmodule.exports = reqs;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/freetext/providers/index.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/freetext/providers/index.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.1.2\n */\n\n'use strict';\n\n(function () {\n  \"use strict\";\n  function lib$es6$promise$utils$$objectOrFunction(x) {\n    return typeof x === 'function' || typeof x === 'object' && x !== null;\n  }\n\n  function lib$es6$promise$utils$$isFunction(x) {\n    return typeof x === 'function';\n  }\n\n  function lib$es6$promise$utils$$isMaybeThenable(x) {\n    return typeof x === 'object' && x !== null;\n  }\n\n  var lib$es6$promise$utils$$_isArray;\n  if (!Array.isArray) {\n    lib$es6$promise$utils$$_isArray = function (x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    };\n  } else {\n    lib$es6$promise$utils$$_isArray = Array.isArray;\n  }\n\n  var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n  var lib$es6$promise$asap$$len = 0;\n  var lib$es6$promise$asap$$vertxNext;\n  var lib$es6$promise$asap$$customSchedulerFn;\n\n  var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n    lib$es6$promise$asap$$len += 2;\n    if (lib$es6$promise$asap$$len === 2) {\n      // If len is 2, that means that we need to schedule an async flush.\n      // If additional callbacks are queued before the queue is flushed, they\n      // will be processed by this flush that we are scheduling.\n      if (lib$es6$promise$asap$$customSchedulerFn) {\n        lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n      } else {\n        lib$es6$promise$asap$$scheduleFlush();\n      }\n    }\n  };\n\n  function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n    lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n  }\n\n  function lib$es6$promise$asap$$setAsap(asapFn) {\n    lib$es6$promise$asap$$asap = asapFn;\n  }\n\n  var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;\n  var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n  var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n  var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n  // test for web worker but not in IE10\n  var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n  // node\n  function lib$es6$promise$asap$$useNextTick() {\n    // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n    // see https://github.com/cujojs/when/issues/410 for details\n    return function () {\n      process.nextTick(lib$es6$promise$asap$$flush);\n    };\n  }\n\n  // vertx\n  function lib$es6$promise$asap$$useVertxTimer() {\n    return function () {\n      lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n    };\n  }\n\n  function lib$es6$promise$asap$$useMutationObserver() {\n    var iterations = 0;\n    var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n    var node = document.createTextNode('');\n    observer.observe(node, { characterData: true });\n\n    return function () {\n      node.data = iterations = ++iterations % 2;\n    };\n  }\n\n  // web worker\n  function lib$es6$promise$asap$$useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = lib$es6$promise$asap$$flush;\n    return function () {\n      channel.port2.postMessage(0);\n    };\n  }\n\n  function lib$es6$promise$asap$$useSetTimeout() {\n    return function () {\n      setTimeout(lib$es6$promise$asap$$flush, 1);\n    };\n  }\n\n  var lib$es6$promise$asap$$queue = new Array(1000);\n  function lib$es6$promise$asap$$flush() {\n    for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {\n      var callback = lib$es6$promise$asap$$queue[i];\n      var arg = lib$es6$promise$asap$$queue[i + 1];\n\n      callback(arg);\n\n      lib$es6$promise$asap$$queue[i] = undefined;\n      lib$es6$promise$asap$$queue[i + 1] = undefined;\n    }\n\n    lib$es6$promise$asap$$len = 0;\n  }\n\n  function lib$es6$promise$asap$$attemptVertx() {\n    try {\n      var r = require;\n      var vertx = __webpack_require__(16);\n      lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return lib$es6$promise$asap$$useVertxTimer();\n    } catch (e) {\n      return lib$es6$promise$asap$$useSetTimeout();\n    }\n  }\n\n  var lib$es6$promise$asap$$scheduleFlush;\n  // Decide what async method to use to triggering processing of queued callbacks:\n  if (lib$es6$promise$asap$$isNode) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n  } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n  } else if (lib$es6$promise$asap$$isWorker) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n  } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n  } else {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n  }\n  function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n    var parent = this;\n    var state = parent._state;\n\n    if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n      return this;\n    }\n\n    var child = new this.constructor(lib$es6$promise$$internal$$noop);\n    var result = parent._result;\n\n    if (state) {\n      var callback = arguments[state - 1];\n      lib$es6$promise$asap$$asap(function () {\n        lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n      });\n    } else {\n      lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n    }\n\n    return child;\n  }\n  var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n  function lib$es6$promise$promise$resolve$$resolve(object) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (object && typeof object === 'object' && object.constructor === Constructor) {\n      return object;\n    }\n\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n    lib$es6$promise$$internal$$resolve(promise, object);\n    return promise;\n  }\n  var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\n  function lib$es6$promise$$internal$$noop() {}\n\n  var lib$es6$promise$$internal$$PENDING = void 0;\n  var lib$es6$promise$$internal$$FULFILLED = 1;\n  var lib$es6$promise$$internal$$REJECTED = 2;\n\n  var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n  function lib$es6$promise$$internal$$selfFulfillment() {\n    return new TypeError(\"You cannot resolve a promise with itself\");\n  }\n\n  function lib$es6$promise$$internal$$cannotReturnOwn() {\n    return new TypeError('A promises callback cannot return that same promise.');\n  }\n\n  function lib$es6$promise$$internal$$getThen(promise) {\n    try {\n      return promise.then;\n    } catch (error) {\n      lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n      return lib$es6$promise$$internal$$GET_THEN_ERROR;\n    }\n  }\n\n  function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n    try {\n      then.call(value, fulfillmentHandler, rejectionHandler);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n    lib$es6$promise$asap$$asap(function (promise) {\n      var sealed = false;\n      var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n        if (thenable !== value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, value);\n        }\n      }, function (reason) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n      if (!sealed && error) {\n        sealed = true;\n        lib$es6$promise$$internal$$reject(promise, error);\n      }\n    }, promise);\n  }\n\n  function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n    if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n      lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n    } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n      lib$es6$promise$$internal$$reject(promise, thenable._result);\n    } else {\n      lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }, function (reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      });\n    }\n  }\n\n  function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n    if (maybeThenable.constructor === promise.constructor && then === lib$es6$promise$then$$default && constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n      lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n    } else {\n      if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n      } else if (then === undefined) {\n        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n      } else if (lib$es6$promise$utils$$isFunction(then)) {\n        lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n      }\n    }\n  }\n\n  function lib$es6$promise$$internal$$resolve(promise, value) {\n    if (promise === value) {\n      lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n    } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n      lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n    } else {\n      lib$es6$promise$$internal$$fulfill(promise, value);\n    }\n  }\n\n  function lib$es6$promise$$internal$$publishRejection(promise) {\n    if (promise._onerror) {\n      promise._onerror(promise._result);\n    }\n\n    lib$es6$promise$$internal$$publish(promise);\n  }\n\n  function lib$es6$promise$$internal$$fulfill(promise, value) {\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      return;\n    }\n\n    promise._result = value;\n    promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n    if (promise._subscribers.length !== 0) {\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n    }\n  }\n\n  function lib$es6$promise$$internal$$reject(promise, reason) {\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      return;\n    }\n    promise._state = lib$es6$promise$$internal$$REJECTED;\n    promise._result = reason;\n\n    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n  }\n\n  function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n    var subscribers = parent._subscribers;\n    var length = subscribers.length;\n\n    parent._onerror = null;\n\n    subscribers[length] = child;\n    subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n    subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;\n\n    if (length === 0 && parent._state) {\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n    }\n  }\n\n  function lib$es6$promise$$internal$$publish(promise) {\n    var subscribers = promise._subscribers;\n    var settled = promise._state;\n\n    if (subscribers.length === 0) {\n      return;\n    }\n\n    var child,\n        callback,\n        detail = promise._result;\n\n    for (var i = 0; i < subscribers.length; i += 3) {\n      child = subscribers[i];\n      callback = subscribers[i + settled];\n\n      if (child) {\n        lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n      } else {\n        callback(detail);\n      }\n    }\n\n    promise._subscribers.length = 0;\n  }\n\n  function lib$es6$promise$$internal$$ErrorObject() {\n    this.error = null;\n  }\n\n  var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n  function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n    try {\n      return callback(detail);\n    } catch (e) {\n      lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n      return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n    }\n  }\n\n  function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n    var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n        value,\n        error,\n        succeeded,\n        failed;\n\n    if (hasCallback) {\n      value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n      if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n        failed = true;\n        error = value.error;\n        value = null;\n      } else {\n        succeeded = true;\n      }\n\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n        return;\n      }\n    } else {\n      value = detail;\n      succeeded = true;\n    }\n\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      // noop\n    } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n  }\n\n  function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n    try {\n      resolver(function resolvePromise(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }, function rejectPromise(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      });\n    } catch (e) {\n      lib$es6$promise$$internal$$reject(promise, e);\n    }\n  }\n\n  function lib$es6$promise$promise$all$$all(entries) {\n    return new lib$es6$promise$enumerator$$default(this, entries).promise;\n  }\n  var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n  function lib$es6$promise$promise$race$$race(entries) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n    if (!lib$es6$promise$utils$$isArray(entries)) {\n      lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n      return promise;\n    }\n\n    var length = entries.length;\n\n    function onFulfillment(value) {\n      lib$es6$promise$$internal$$resolve(promise, value);\n    }\n\n    function onRejection(reason) {\n      lib$es6$promise$$internal$$reject(promise, reason);\n    }\n\n    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n      lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n    }\n\n    return promise;\n  }\n  var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n  function lib$es6$promise$promise$reject$$reject(reason) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n    lib$es6$promise$$internal$$reject(promise, reason);\n    return promise;\n  }\n  var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n  var lib$es6$promise$promise$$counter = 0;\n\n  function lib$es6$promise$promise$$needsResolver() {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  function lib$es6$promise$promise$$needsNew() {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n  /**\n    Promise objects represent the eventual result of an asynchronous operation. The\n    primary way of interacting with a promise is through its `then` method, which\n    registers callbacks to receive either a promise's eventual value or the reason\n    why the promise cannot be fulfilled.\n     Terminology\n    -----------\n     - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n    - `thenable` is an object or function that defines a `then` method.\n    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n    - `exception` is a value that is thrown using the throw statement.\n    - `reason` is a value that indicates why a promise was rejected.\n    - `settled` the final resting state of a promise, fulfilled or rejected.\n     A promise can be in one of three states: pending, fulfilled, or rejected.\n     Promises that are fulfilled have a fulfillment value and are in the fulfilled\n    state.  Promises that are rejected have a rejection reason and are in the\n    rejected state.  A fulfillment value is never a thenable.\n     Promises can also be said to *resolve* a value.  If this value is also a\n    promise, then the original promise's settled state will match the value's\n    settled state.  So a promise that *resolves* a promise that rejects will\n    itself reject, and a promise that *resolves* a promise that fulfills will\n    itself fulfill.\n      Basic Usage:\n    ------------\n     ```js\n    var promise = new Promise(function(resolve, reject) {\n      // on success\n      resolve(value);\n       // on failure\n      reject(reason);\n    });\n     promise.then(function(value) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n     Advanced Usage:\n    ---------------\n     Promises shine when abstracting away asynchronous interactions such as\n    `XMLHttpRequest`s.\n     ```js\n    function getJSON(url) {\n      return new Promise(function(resolve, reject){\n        var xhr = new XMLHttpRequest();\n         xhr.open('GET', url);\n        xhr.onreadystatechange = handler;\n        xhr.responseType = 'json';\n        xhr.setRequestHeader('Accept', 'application/json');\n        xhr.send();\n         function handler() {\n          if (this.readyState === this.DONE) {\n            if (this.status === 200) {\n              resolve(this.response);\n            } else {\n              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n            }\n          }\n        };\n      });\n    }\n     getJSON('/posts.json').then(function(json) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n     Unlike callbacks, promises are great composable primitives.\n     ```js\n    Promise.all([\n      getJSON('/posts'),\n      getJSON('/comments')\n    ]).then(function(values){\n      values[0] // => postsJSON\n      values[1] // => commentsJSON\n       return values;\n    });\n    ```\n     @class Promise\n    @param {function} resolver\n    Useful for tooling.\n    @constructor\n  */\n  function lib$es6$promise$promise$$Promise(resolver) {\n    this._id = lib$es6$promise$promise$$counter++;\n    this._state = undefined;\n    this._result = undefined;\n    this._subscribers = [];\n\n    if (lib$es6$promise$$internal$$noop !== resolver) {\n      typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n      this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n    }\n  }\n\n  lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n  lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n  lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n  lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n  lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n  lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n  lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n  lib$es6$promise$promise$$Promise.prototype = {\n    constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n       ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n       Chaining\n      --------\n       The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n       ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n       findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n       ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n       Assimilation\n      ------------\n       Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n       If the assimliated promise rejects, then the downstream promise will also reject.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n       Simple Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var result;\n       try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n       Advanced Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var author, books;\n       try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n       function foundBooks(books) {\n       }\n       function failure(reason) {\n       }\n       findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n    then: lib$es6$promise$then$$default,\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n       ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n       // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n       // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n    'catch': function _catch(onRejection) {\n      return this.then(null, onRejection);\n    }\n  };\n  var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n  function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n    if (Array.isArray(input)) {\n      this._input = input;\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate();\n        if (this._remaining === 0) {\n          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      lib$es6$promise$$internal$$reject(this.promise, this._validationError());\n    }\n  }\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function () {\n    return new Error('Array Methods must be provided an Array');\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {\n    var length = this.length;\n    var input = this._input;\n\n    for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {\n    var c = this._instanceConstructor;\n    var resolve = c.resolve;\n\n    if (resolve === lib$es6$promise$promise$resolve$$default) {\n      var then = lib$es6$promise$$internal$$getThen(entry);\n\n      if (then === lib$es6$promise$then$$default && entry._state !== lib$es6$promise$$internal$$PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === lib$es6$promise$promise$$default) {\n        var promise = new c(lib$es6$promise$$internal$$noop);\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve) {\n          resolve(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve(entry), i);\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {\n    var promise = this.promise;\n\n    if (promise._state === lib$es6$promise$$internal$$PENDING) {\n      this._remaining--;\n\n      if (state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      lib$es6$promise$$internal$$fulfill(promise, this._result);\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {\n    var enumerator = this;\n\n    lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {\n      enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n    }, function (reason) {\n      enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n    });\n  };\n  function lib$es6$promise$polyfill$$polyfill() {\n    var local;\n\n    if (typeof global !== 'undefined') {\n      local = global;\n    } else if (typeof self !== 'undefined') {\n      local = self;\n    } else {\n      try {\n        local = Function('return this')();\n      } catch (e) {\n        throw new Error('polyfill failed because global object is unavailable in this environment');\n      }\n    }\n\n    var P = local.Promise;\n\n    if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n      return;\n    }\n\n    local.Promise = lib$es6$promise$promise$$default;\n  }\n  var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n  var lib$es6$promise$umd$$ES6Promise = {\n    'Promise': lib$es6$promise$promise$$default,\n    'polyfill': lib$es6$promise$polyfill$$default\n  };\n\n  /* global define:true module:true window: true */\n  if (\"function\" === 'function' && __webpack_require__(13)['amd']) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return lib$es6$promise$umd$$ES6Promise;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module !== 'undefined' && module['exports']) {\n    module['exports'] = lib$es6$promise$umd$$ES6Promise;\n  } else if (typeof this !== 'undefined') {\n    this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n  }\n\n  lib$es6$promise$polyfill$$default();\n}).call(undefined);\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = global.Promise;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), (function() { return this; }()), __webpack_require__(3)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/exports-loader?global.Promise!./~/es6-promise/dist/es6-promise.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-promise/dist/es6-promise.js?./~/exports-loader?global.Promise");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("\"use strict\";\n/**\n * A mixin that adds support for event emitting\n */\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        this.listeners = {};\n    }\n    /**\n     * Adds an event listener for the given event\n     */\n    EventEmitter.prototype.on = function (name, handler) {\n        var _this = this;\n        var listeners = this.listeners[name] = this.listeners[name] || [];\n        listeners.push(handler);\n        return {\n            destroy: function () {\n                _this.off(name, handler);\n            }\n        };\n    };\n    /**\n     * Removes an event listener for the given event\n     */\n    EventEmitter.prototype.off = function (name, handler) {\n        var listeners = this.listeners[name];\n        if (listeners) {\n            var idx = listeners.indexOf(handler);\n            if (idx >= 0) {\n                listeners.splice(idx, 1);\n            }\n        }\n    };\n    /**\n     * Raises the given event\n     */\n    /*protected*/ EventEmitter.prototype.raiseEvent = function (name) {\n        var _this = this;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var listeners = this.listeners[name];\n        if (listeners) {\n            listeners.forEach(function (l) {\n                l.apply(_this, args);\n            });\n        }\n    };\n    return EventEmitter;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./base/EventEmitter.ts\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./base/EventEmitter.ts?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar EventEmitter_1 = __webpack_require__(7);\nvar $ = __webpack_require__(15);\nvar naturalSort = __webpack_require__(2);\n/**\n * Represents an advanced slicer to help slice through data\n */\nvar AttributeSlicer = (function () {\n    /**\n     * Constructor for the advanced slicer\n     */\n    function AttributeSlicer(element) {\n        var _this = this;\n        /**\n         * The data contained in this slicer\n         */\n        this._data = [];\n        /**\n         * Our event emitter\n         */\n        this._eventEmitter = new EventEmitter_1.default();\n        /**\n         * Whether or not we are loading the search box\n         */\n        this.loadingSearch = false;\n        /**\n         * Setter for server side search\n         */\n        this._serverSideSearch = true;\n        /**\n         * The list of selected items\n         */\n        this._selectedItems = [];\n        /**\n         * A boolean indicating whether or not the list is loading more data\n         */\n        this._loadingMoreData = false; // Don't use this directly\n        this.element = element;\n        this.listContainer = element.append($(AttributeSlicer.template)).find(\".advanced-slicer\");\n        this.listEle = this.listContainer.find(\".list\");\n        this.listEle.scroll(function () { return _this.checkLoadMoreData(); });\n        this.selectionsEle = element.find(\".selections\");\n        this.checkAllEle = element.find(\".check-all\").on(\"click\", function () { return _this.toggleSelectAll(); });\n        this.clearAllEle = element.find(\".clear-all\").on(\"click\", function () { return _this.clearSelection(); });\n        this.attachEvents();\n        // These two are here because the devtools call init more than once\n        this.loadingMoreData = true;\n    }\n    Object.defineProperty(AttributeSlicer.prototype, \"serverSideSearch\", {\n        /**\n         * Getter for server side search\n         */\n        get: function () {\n            return this._serverSideSearch;\n        },\n        set: function (value) {\n            this._serverSideSearch = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"events\", {\n        /**\n         * Gets our event emitter\n         */\n        get: function () {\n            return this._eventEmitter;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"dimensions\", {\n        /**\n         * Sets the dimension of the slicer\n         */\n        set: function (dims) {\n            this.listEle.find(\".display-container\").css({ width: \"100%\" });\n            this.listEle.css({ width: \"100%\", height: dims.height - this.element.find(\".slicer-options\").height() - 10 });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"showValues\", {\n        /**\n         * Setter for showing the values column\n         */\n        set: function (show) {\n            this.element.toggleClass(\"has-values\", show);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"showSelections\", {\n        /**\n         * Setter for showing the selections area\n         */\n        set: function (show) {\n            this.element.toggleClass(\"show-selections\", show);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"showHighlight\", {\n        /**\n         * Gets whether or not we are showing the highlights\n         */\n        get: function () {\n            return this.element.hasClass(\"show-highlight\");\n        },\n        /**\n         * Toggles whether or not to show highlights\n         */\n        set: function (highlight) {\n            this.element.toggleClass(\"show-highlight\", !!highlight);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"data\", {\n        /**\n         * Gets the data behind the slicer\n         */\n        get: function () {\n            return this._data;\n        },\n        /**\n         * Sets the slicer data\n         */\n        set: function (newData) {\n            this.listEle.empty();\n            // If some one sets the data, then clearly we are no longer loading data\n            this.loadingMoreData = false;\n            if (newData && newData.length) {\n                this.listEle.append(newData.map(function (item) {\n                    var ele = AttributeSlicer.listItemFactory(item.matchPrefix, item.match, item.matchSuffix);\n                    var renderedValue = item.renderedValue;\n                    if (renderedValue) {\n                        var valueDisplayEle = ele.find(\".value-display\");\n                        valueDisplayEle.css({ width: (renderedValue + \"%\") });\n                        valueDisplayEle.find(\".value\").html('' + item.value);\n                    }\n                    ele[item.selected ? \"hide\" : \"show\"].call(ele);\n                    ele.find(\"input\").prop('checked', item.selected);\n                    ele.data(\"item\", item);\n                    return ele;\n                }));\n                this.loadingSearch = true;\n                this.element.find(\".searchbox\").val(this.searchString);\n                this.loadingSearch = false;\n                this._data = newData;\n                this.updateSelectAllButtonState();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"selectedItems\", {\n        get: function () {\n            return this._selectedItems;\n        },\n        /**\n         * Sets the set of selected items\n         */\n        set: function (value) {\n            var _this = this;\n            var oldSelection = this.selectedItems.slice(0);\n            this._selectedItems = value;\n            // HACK: They are all selected if it is the same length as our dataset\n            var allChecked = value && value.length === this.data.length;\n            var someChecked = value && value.length > 0 && !allChecked;\n            this.syncItemVisiblity();\n            if (value) {\n                this.selectionsEle.find(\".token\").remove();\n                value.map(function (v) { return _this.createSelectionToken(v); }).forEach(function (n) { return n.insertBefore(_this.element.find(\".clear-all\")); });\n            }\n            this.raiseSelectionChanged(this.selectedItems, oldSelection);\n            this.checkAllEle.prop(\"checked\", someChecked);\n            this.checkAllEle.prop('indeterminate', someChecked);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttributeSlicer.prototype, \"searchString\", {\n        /**\n         * Gets the current serch value\n         */\n        get: function () {\n            return this.element.find(\".searchbox\").val();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**j\n     * Sorts the slicer\n     */\n    AttributeSlicer.prototype.sort = function (toSort, desc) {\n        this.data.sort(function (a, b) {\n            var sortVal = naturalSort(a[toSort], b[toSort]);\n            return desc ? -1 * sortVal : sortVal;\n        });\n    };\n    Object.defineProperty(AttributeSlicer.prototype, \"loadingMoreData\", {\n        get: function () {\n            return this._loadingMoreData;\n        },\n        /**\n         * Setter for loadingMoreData\n         */\n        set: function (value) {\n            this._loadingMoreData = value;\n            this.element.toggleClass(\"loading\", value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Syncs the item elements state with the current set of selected items and the search\n     */\n    AttributeSlicer.prototype.syncItemVisiblity = function () {\n        var value = this.selectedItems;\n        var eles = this.element.find(\".item\");\n        var me = this;\n        var isMatch = function (item, value) {\n            return ((item.match + \"\") || \"\").indexOf(value) >= 0 ||\n                ((item.matchPrefix + \"\") || \"\").indexOf(value) >= 0 ||\n                ((item.matchSuffix + \"\") || \"\").indexOf(value) >= 0;\n        };\n        eles.each(function () {\n            var item = $(this).data(\"item\");\n            var isVisible = !(!!value && value.filter(function (b) { return b.equals(item); }).length > 0);\n            // Update the search\n            if (isVisible && !me.serverSideSearch && me.searchString) {\n                isVisible = isMatch(item, me.searchString);\n            }\n            $(this).toggle(isVisible);\n        });\n    };\n    /**\n     * Toggle the select all state\n     */\n    AttributeSlicer.prototype.toggleSelectAll = function () {\n        var checked = this.checkAllEle.prop('checked');\n        if (!!checked) {\n            this.selectedItems = this._data.slice(0);\n        }\n        else {\n            this.selectedItems = [];\n        }\n    };\n    /**\n     * Creates a new selection token element\n     */\n    AttributeSlicer.prototype.createSelectionToken = function (v) {\n        var _this = this;\n        var newEle = $('<div/>');\n        var text = (v.matchPrefix || \"\") + v.match + (v.matchSuffix || \"\");\n        newEle\n            .addClass(\"token\")\n            .attr(\"title\", text)\n            .data(\"item\", v)\n            .on(\"click\", function () {\n            newEle.remove();\n            var item = _this.selectedItems.filter(function (n) { return n.equals(v); })[0];\n            _this.selectedItems.splice(_this.selectedItems.indexOf(item), 1);\n            _this.selectedItems = _this.selectedItems.slice(0);\n        })\n            .text(text);\n        return newEle;\n    };\n    /**\n     * Clears the selection\n     */\n    AttributeSlicer.prototype.clearSelection = function () {\n        this.selectedItems = [];\n    };\n    /**\n     * Updates the select all button state to match the data\n     */\n    AttributeSlicer.prototype.updateSelectAllButtonState = function () {\n        this.checkAllEle.prop('indeterminate', this.selectedItems.length > 0 && this._data.length !== this.selectedItems.length);\n        this.checkAllEle.prop('checked', this.selectedItems.length > 0);\n    };\n    /**\n     * Attaches all the necessary events\n     */\n    AttributeSlicer.prototype.attachEvents = function () {\n        var _this = this;\n        this.element.find(\".searchbox\").on(\"input\", _.debounce(function () {\n            if (!_this.loadingSearch) {\n                if (_this.serverSideSearch) {\n                    setTimeout(function () { return _this.checkLoadMoreDataBasedOnSearch(); }, 10);\n                }\n                // this is required because when the list is done searching it adds back in cached elements with selected flags\n                _this.syncItemVisiblity();\n                _this.element.toggleClass(\"has-search\", !!_this.searchString);\n            }\n        }, AttributeSlicer.SEARCH_DEBOUNCE));\n        this.listEle.on(\"click\", function (evt) {\n            // var checkbox = $(evt.target);\n            var ele = $(evt.target).parents(\".item\");\n            if (ele.length > 0) {\n                var item = ele.data(\"item\");\n                _this.selectedItems.push(item);\n                _this.selectedItems = _this.selectedItems.slice(0);\n                _this.updateSelectAllButtonState();\n            }\n            evt.stopImmediatePropagation();\n            evt.stopPropagation();\n        });\n    };\n    /**\n     * Loads more data based on search\n     * @param force Force the loading of new data, if it can\n     */\n    AttributeSlicer.prototype.checkLoadMoreDataBasedOnSearch = function () {\n        // Only need to load if:\n        // 1. There is more data. 2. There is not too much stuff on the screen (not causing a scroll)\n        if (this.raiseCanLoadMoreData(true)) {\n            if (this.loadPromise) {\n                this.loadPromise['cancel'] = true;\n            }\n            // We're not currently loading data, cause we cancelled\n            this.loadingMoreData = false;\n            this.raiseLoadMoreData(true);\n        }\n    };\n    /**\n     * Listener for the list scrolling\n     */\n    AttributeSlicer.prototype.checkLoadMoreData = function () {\n        var scrollElement = this.listEle[0];\n        var scrollHeight = scrollElement.scrollHeight;\n        var top = scrollElement.scrollTop;\n        var shouldScrollLoad = scrollHeight - (top + scrollElement.clientHeight) < 200 && scrollHeight >= 200;\n        if (shouldScrollLoad && !this.loadingMoreData && this.raiseCanLoadMoreData()) {\n            this.raiseLoadMoreData(false);\n        }\n    };\n    /**\n     * Raises the event to load more data\n     */\n    AttributeSlicer.prototype.raiseLoadMoreData = function (isNewSearch) {\n        var _this = this;\n        var item = {};\n        this.events.raiseEvent(\"loadMoreData\", item, isNewSearch, this.searchString);\n        if (item.result) {\n            this.loadingMoreData = true;\n            var promise_1 = this.loadPromise = item.result.then(function (items) {\n                // If this promise hasn't been cancelled\n                if (!promise_1['cancel']) {\n                    _this.loadingMoreData = false;\n                    _this.loadPromise = undefined;\n                    if (isNewSearch) {\n                        _this.data = items;\n                    }\n                    else {\n                        _this.data = _this.data.concat(items);\n                    }\n                    // Make sure we don't need to load more after this, in case it doesn't all fit on the screen\n                    setTimeout(function () { return _this.checkLoadMoreData(); }, 10);\n                    return items;\n                }\n            }, function () {\n                _this.data = [];\n                _this.loadingMoreData = false;\n            });\n            return promise_1;\n        }\n    };\n    /**\n     * Raises the event 'can\n     * '\n     */\n    AttributeSlicer.prototype.raiseCanLoadMoreData = function (isSearch) {\n        if (isSearch === void 0) { isSearch = false; }\n        var item = {\n            result: false\n        };\n        this.events.raiseEvent('canLoadMoreData', item, isSearch);\n        return item.result;\n    };\n    /**\n     * Raises the selectionChanged event\n     */\n    AttributeSlicer.prototype.raiseSelectionChanged = function (newItems, oldItems) {\n        this.events.raiseEvent('selectionChanged', newItems, oldItems);\n    };\n    /**\n     * The number of milliseconds before running the search, after a user stops typing.\n     */\n    AttributeSlicer.SEARCH_DEBOUNCE = 500;\n    /**\n     * The template for this visual\n     */\n    AttributeSlicer.template = \"\\n        <div class=\\\"advanced-slicer\\\">\\n            <div class=\\\"slicer-options\\\">\\n                <input class=\\\"searchbox\\\" placeholder=\\\"Search\\\" />\\n                <div style=\\\"margin:0;padding:0;margin-top:5px;\\\">\\n                <div class=\\\"selection-container\\\">\\n                    <div class=\\\"selections\\\">\\n                        <span class=\\\"clear-all\\\">Clear All</span>\\n                    </div>\\n                </div>\\n                <!-- Disabled -->\\n                <label style=\\\"display:none;vertical-align:middle\\\"><input class=\\\"check-all\\\" type=\\\"checkbox\\\" style=\\\"margin-right:5px;vertical-align:middle\\\"/>&nbsp;Select All</label>\\n                </div>\\n                <hr/>\\n            </div>\\n            <div class=\\\"list\\\" style=\\\"overflow:hidden;overflow-y:auto\\\"></div>\\n            <div class='load-spinner' style='transform:scale(0.6);'><div>\\n        </div>\\n    \".trim().replace(/\\n/g, '');\n    /**\n     * The template used to render list items\n     */\n    AttributeSlicer.listItemFactory = function (matchPrefix, match, matchSuffix) {\n        return $((\"\\n            <div style=\\\"white-space:nowrap\\\" class=\\\"item\\\">\\n                <label style=\\\"cursor:pointer\\\">\\n                    <!--<input style=\\\"vertical-align:middle;cursor:pointer\\\" type=\\\"checkbox\\\">-->\\n                    <span style=\\\"margin-left: 5px;vertical-align:middle\\\" class=\\\"display-container\\\">\\n                        <span style=\\\"display:inline-block;overflow:hidden\\\" class=\\\"category-container\\\">\\n                            <span class=\\\"matchPrefix\\\">\" + (matchPrefix || \"\") + \"</span>\\n                            <span class=\\\"match\\\">\" + (match || \"\") + \"</span>\\n                            <span class=\\\"matchSuffix\\\">\" + (matchSuffix || \"\") + \"</span>\\n                        </span>\\n                        <span style=\\\"display:inline-block\\\" class=\\\"value-container\\\">\\n                            <span style=\\\"display:inline-block;width:0px\\\" class=\\\"value-display\\\">&nbsp;<span class=\\\"value\\\"></span></span>\\n                        </span>\\n                    </span>\\n                </label>\\n            </div>\\n        \").trim().replace(/\\n/g, ''));\n    };\n    return AttributeSlicer;\n}());\nexports.AttributeSlicer = AttributeSlicer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/attributeslicer/AttributeSlicer.ts\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/attributeslicer/AttributeSlicer.ts?");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("\"use strict\";\n/**\n * Represents an azure search provider\n */\nvar AzureSearchProvider = (function () {\n    /**\n     * Constructor for the search provider\n     */\n    function AzureSearchProvider(params) {\n        /**\n         * The name of the search provider\n         */\n        this.name = \"Azure\";\n        this.params = params;\n    }\n    Object.defineProperty(AzureSearchProvider.prototype, \"params\", {\n        get: function () {\n            return this._params;\n        },\n        /**\n         * Sets the params of the search provider\n         */\n        set: function (params) {\n            this._params = params;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Runs a query against the given search provider\n     */\n    AzureSearchProvider.prototype.query = function (options) {\n        var _this = this;\n        if (this.checkRequiredParams()) {\n            var idField_1 = this.getParamValue(AzureSearchProvider.ID_FIELD_PARAM);\n            return $.ajax({\n                dataType: \"json\",\n                url: this.buildQueryUrl(options),\n                method: \"GET\",\n                crossDomain: true,\n                beforeSend: function (request) {\n                    request.withCredentials = true;\n                    request.setRequestHeader(\"Api-Key\", _this.getParamValue(AzureSearchProvider.API_KEY_PARAM));\n                }\n            }).then(function (results) {\n                return {\n                    results: results.value.map(function (r) {\n                        var prop = (_this.getParamValue(AzureSearchProvider.SEARCH_FIELDS) || \"body\").split(',')[0];\n                        return {\n                            id: r[idField_1],\n                            textualMatch: r[prop] || \"\",\n                            rawData: r.value\n                        };\n                    }),\n                    total: results[\"@odata.count\"],\n                    offset: options.offset\n                };\n            });\n        }\n        else {\n            throw new Error(\"Some Required Parameters Missing\");\n        }\n    };\n    /**\n     * Checks the list of require params\n     */\n    AzureSearchProvider.prototype.checkRequiredParams = function () {\n        if (this.params && this.params.length) {\n            var required = AzureSearchProvider.supportedParameters.filter(function (p) { return p.required; }).map(function (p) { return p.name; });\n            var toCheck = this.params.map(function (p) { return p.name; });\n            // Make sure that we have all the required params\n            return required.filter(function (p) { return toCheck.indexOf(p) >= 0; }).length === required.length;\n        }\n        return false;\n    };\n    /**\n     * Gets the parameter value by name\n     */\n    AzureSearchProvider.prototype.getParamValue = function (name) {\n        return this.params.filter(function (p) { return p.name === name; }).map(function (p) { return p.value; })[0];\n    };\n    /**\n     * Builds a query url from query options\n     */\n    AzureSearchProvider.prototype.buildQueryUrl = function (options) {\n        var baseUrl = this.getParamValue(AzureSearchProvider.URL_PARAM);\n        var urlParams = [\n            { key: \"api-version\", value: \"2015-02-28\" },\n            { key: \"$count\", value: true } // Returns the total number of results\n        ];\n        if (options.offset >= 0) {\n            urlParams.push({ key: \"$skip\", value: options.offset });\n        }\n        if (options.count >= 0) {\n            urlParams.push({ key: \"$top\", value: options.count });\n        }\n        var searchFields = this.getParamValue(AzureSearchProvider.SEARCH_FIELDS) || [];\n        var eq = options.query && options.query.where && options.query.where.eq;\n        if (eq) {\n            var searchColumns = Object.keys(eq);\n            var cleared_1 = false;\n            // This will allow for overriding of column based searches, so `title:Haha`, if * is used, then all columns in the search fields parameters is used\n            var search = searchColumns.map(function (c) {\n                if (c !== '*') {\n                    if (!cleared_1) {\n                        cleared_1 = true;\n                        searchFields.length = 0;\n                    }\n                    searchFields.push(c);\n                }\n                return eq[c];\n            }).join(\" \");\n            urlParams.push({ key: \"search\", value: search || '*' });\n        }\n        else {\n            urlParams.push({ key: \"search\", value: '*' });\n        }\n        if (searchFields && searchFields.length) {\n            urlParams.push({ key: \"searchFields\", value: searchFields });\n        }\n        return baseUrl + \"?\" + urlParams.map(function (p) { return p.key + \"=\" + p.value; }).join(\"&\");\n    };\n    /**\n     * The API Key param\n     */\n    AzureSearchProvider.API_KEY_PARAM = \"API Key\";\n    /**\n     * The field that uniquely identifies a given result\n     */\n    AzureSearchProvider.ID_FIELD_PARAM = \"ID Field\";\n    /**\n     * The URL param\n     */\n    AzureSearchProvider.URL_PARAM = \"URL\";\n    /**\n     * The fields to search when performing a text search\n     */\n    AzureSearchProvider.SEARCH_FIELDS = \"Search Fields\";\n    /**\n     * The parameters to call this service\n     * for example - API Key, URL\n     */\n    AzureSearchProvider.supportedParameters = [{\n            name: AzureSearchProvider.URL_PARAM,\n            description: \"The URL to the Azure Search Instance\",\n            value: undefined,\n            required: true\n        }, {\n            name: AzureSearchProvider.API_KEY_PARAM,\n            description: \"The API Key\",\n            value: undefined,\n            required: true\n        }, {\n            name: AzureSearchProvider.ID_FIELD_PARAM,\n            description: \"The field that uniquely identifies a given result\",\n            value: \"emailid\",\n            required: true\n        }, {\n            name: AzureSearchProvider.SEARCH_FIELDS,\n            description: \"The fields to search when running a query (comma delimited)\",\n            value: \"body\",\n            required: false\n        }];\n    return AzureSearchProvider;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = AzureSearchProvider;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/freetext/providers/AzureSearchProvider.ts\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/freetext/providers/AzureSearchProvider.ts?");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("\"use strict\";\n/**\n * Represents an elastic search provider\n */\nvar ElasticSearchSearchProvider = (function () {\n    /**\n     * Constructor for the search provider\n     */\n    function ElasticSearchSearchProvider(params) {\n        /**\n         * The name of the search provider\n         */\n        this.name = \"ElasticSearch\";\n        this.params = params;\n    }\n    Object.defineProperty(ElasticSearchSearchProvider.prototype, \"params\", {\n        get: function () {\n            return this._params;\n        },\n        /**\n         * Sets the params of the search provider\n         */\n        set: function (params) {\n            this._params = params;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Runs a query against the given search provider\n     */\n    ElasticSearchSearchProvider.prototype.query = function (options) {\n        var _this = this;\n        if (this.checkRequiredParams()) {\n            var idField_1 = this.getParamValue(ElasticSearchSearchProvider.ID_FIELD_PARAM);\n            return $.ajax({\n                dataType: \"json\",\n                url: this.buildQueryUrl(options),\n                method: \"GET\",\n                crossDomain: true /*,\n                beforeSend: (request) => {\n                    request.withCredentials = true;\n                    request.setRequestHeader(\"Api-Key\", this.getParamValue(ElasticSearchSearchProvider.API_KEY_PARAM));\n                }*/\n            }).then(function (results) {\n                var hits = results.hits.hits;\n                return {\n                    results: (hits || []).map(function (hit) {\n                        var r = hit._source;\n                        var prop = (_this.getParamValue(ElasticSearchSearchProvider.SEARCH_FIELDS) || \"body\").split(',')[0];\n                        return {\n                            id: r[idField_1],\n                            textualMatch: r[prop] || \"\",\n                            rawData: r\n                        };\n                    }),\n                    total: results.hits.total,\n                    offset: options.offset\n                };\n            });\n        }\n        else {\n            throw new Error(\"Some Required Parameters Missing\");\n        }\n    };\n    /**\n     * Checks the list of require params\n     */\n    ElasticSearchSearchProvider.prototype.checkRequiredParams = function () {\n        if (this.params && this.params.length) {\n            var required = ElasticSearchSearchProvider.supportedParameters.filter(function (p) { return p.required; }).map(function (p) { return p.name; });\n            var toCheck = this.params.map(function (p) { return p.name; });\n            // Make sure that we have all the required params\n            return required.filter(function (p) { return toCheck.indexOf(p) >= 0; }).length === required.length;\n        }\n        return false;\n    };\n    /**\n     * Gets the parameter value by name\n     */\n    ElasticSearchSearchProvider.prototype.getParamValue = function (name) {\n        return this.params.filter(function (p) { return p.name === name; }).map(function (p) { return p.value; })[0];\n    };\n    /**\n     * Builds a query url from query options\n     */\n    ElasticSearchSearchProvider.prototype.buildQueryUrl = function (options) {\n        var baseUrl = this.getParamValue(ElasticSearchSearchProvider.URL_PARAM);\n        var urlParams = [];\n        if (options.offset >= 0) {\n            urlParams.push({ key: \"from\", value: options.offset });\n        }\n        if (options.count >= 0) {\n            urlParams.push({ key: \"size\", value: options.count });\n        }\n        var searchFields = [this.getParamValue(ElasticSearchSearchProvider.SEARCH_FIELDS)] || [];\n        var eq = options.query && options.query.where && options.query.where.eq;\n        if (eq) {\n            var searchColumns = Object.keys(eq);\n            var cleared_1 = false;\n            // This will allow for overriding of column based searches, so `title:Haha`, if * is used, then all columns in the search fields parameters is used\n            var search = searchColumns.map(function (c) {\n                if (c !== '*') {\n                    if (!cleared_1) {\n                        cleared_1 = true;\n                        searchFields.length = 0;\n                    }\n                    searchFields.push(c);\n                }\n                return searchFields.map(function (n) { return n + \":\" + \"*\" + eq[c] + \"*\"; }).join(\"OR\");\n            }).join(\" \");\n            urlParams.push({ key: \"q\", value: search || '*' });\n        }\n        // if (searchFields && searchFields.length) {\n        //     urlParams.push({ key: \"fields\", value: searchFields.concat([this.getParamValue(ElasticSearchSearchProvider.ID_FIELD_PARAM)]).join(\",\") });\n        // }\n        return baseUrl + \"?\" + urlParams.map(function (p) { return p.key + \"=\" + p.value; }).join(\"&\");\n    };\n    // /**\n    //  * The API Key param\n    //  */\n    // public static API_KEY_PARAM = \"API Key\";\n    /**\n     * The field that uniquely identifies a given result\n     */\n    ElasticSearchSearchProvider.ID_FIELD_PARAM = \"ID Field\";\n    /**\n     * The URL param\n     */\n    ElasticSearchSearchProvider.URL_PARAM = \"URL\";\n    /**\n     * The fields to search when performing a text search\n     */\n    ElasticSearchSearchProvider.SEARCH_FIELDS = \"Search Fields\";\n    /**\n     * The parameters to call this service\n     * for example - API Key, URL\n     */\n    ElasticSearchSearchProvider.supportedParameters = [{\n            name: ElasticSearchSearchProvider.URL_PARAM,\n            description: \"The URL to the ElasticSearch Instance\",\n            value: undefined,\n            required: true\n        } /*, {\n            name: ElasticSearchSearchProvider.API_KEY_PARAM,\n            description: \"The API Key\",\n            value: undefined,\n            required: true\n        }*/,\n        {\n            name: ElasticSearchSearchProvider.ID_FIELD_PARAM,\n            description: \"The field that uniquely identifies a given result\",\n            value: \"emailid\",\n            required: true\n        }, {\n            name: ElasticSearchSearchProvider.SEARCH_FIELDS,\n            description: \"The fields to search when running a query (comma delimited)\",\n            value: \"body\",\n            required: false\n        }];\n    return ElasticSearchSearchProvider;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ElasticSearchSearchProvider;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/freetext/providers/ElasticSearchSearchProvider.ts\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/freetext/providers/ElasticSearchSearchProvider.ts?");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/freetext/providers/ISearchProvider.ts\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/freetext/providers/ISearchProvider.ts?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Promise) {\"use strict\";\n/**\n * Represents an elastic search provider\n */\nvar JSONSearchProvider = (function () {\n    /**\n     * Constructor for the search provider\n     */\n    function JSONSearchProvider(params, data) {\n        /**\n         * The name of the search provider\n         */\n        this.name = \"JSON\";\n        this.params = params;\n        this.data = data;\n    }\n    Object.defineProperty(JSONSearchProvider.prototype, \"params\", {\n        get: function () {\n            return this._params;\n        },\n        /**\n         * Sets the params of the search provider\n         */\n        set: function (params) {\n            this._params = params;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Runs a query against the given search provider\n     */\n    JSONSearchProvider.prototype.query = function (options) {\n        var _this = this;\n        if (this.checkRequiredParams()) {\n            var idField_1 = this.getParamValue(JSONSearchProvider.ID_FIELD_PARAM);\n            var final_1 = this.data.slice(0);\n            var eq_1 = options.query && options.query.where && options.query.where.eq;\n            if (eq_1) {\n                var searchColumns = Object.keys(eq_1);\n                var cleared = false;\n                // This will allow for overriding of column based searches, so `title:Haha`, if * is used, then all columns in the search fields parameters is used\n                var searchFilters = searchColumns.forEach(function (c) {\n                    var searchValue = eq_1[c];\n                    if (c !== '*') {\n                        final_1 = final_1.filter(function (item) { return item[c].indexOf(searchValue) >= 0; });\n                    }\n                    else {\n                        if (searchValue !== \"*\") {\n                            final_1 = final_1.filter(function (item) {\n                                return Object.keys(item).filter(function (column) {\n                                    var result = item[column];\n                                    if (result && result.indexOf) {\n                                        return result.indexOf(searchValue) >= 0;\n                                    }\n                                }).length > 0;\n                            });\n                        }\n                    }\n                });\n            }\n            var filteredCount_1 = final_1.length;\n            if (options.offset) {\n                final_1 = final_1.slice(options.offset);\n            }\n            if (options.count) {\n                final_1 = final_1.slice(0, options.count);\n            }\n            return new Promise(function (resolve) {\n                setTimeout(function () { return resolve({\n                    results: final_1.map(function (r) {\n                        var prop = (_this.getParamValue(JSONSearchProvider.SEARCH_FIELDS) || \"body\").split(',')[0];\n                        return {\n                            id: r[idField_1],\n                            textualMatch: r[prop] || \"\",\n                            rawData: r\n                        };\n                    }),\n                    total: filteredCount_1,\n                    offset: options.offset\n                }); }, 5000);\n            });\n        }\n        else {\n            throw new Error(\"Some Required Parameters Missing\");\n        }\n    };\n    /**\n     * Checks the list of require params\n     */\n    JSONSearchProvider.prototype.checkRequiredParams = function () {\n        if (this.params && this.params.length) {\n            var required = JSONSearchProvider.supportedParameters.filter(function (p) { return p.required; }).map(function (p) { return p.name; });\n            var toCheck = this.params.map(function (p) { return p.name; });\n            // Make sure that we have all the required params\n            return required.filter(function (p) { return toCheck.indexOf(p) >= 0; }).length === required.length;\n        }\n        return false;\n    };\n    /**\n     * Gets the parameter value by name\n     */\n    JSONSearchProvider.prototype.getParamValue = function (name) {\n        return this.params.filter(function (p) { return p.name === name; }).map(function (p) { return p.value; })[0];\n    };\n    // /**\n    //  * The API Key param\n    //  */\n    // public static API_KEY_PARAM = \"API Key\";\n    /**\n     * The field that uniquely identifies a given result\n     */\n    JSONSearchProvider.ID_FIELD_PARAM = \"ID Field\";\n    /**\n     * The URL param\n     */\n    JSONSearchProvider.URL_PARAM = \"URL\";\n    /**\n     * The fields to search when performing a text search\n     */\n    JSONSearchProvider.SEARCH_FIELDS = \"Search Fields\";\n    /**\n     * The parameters to call this service\n     * for example - API Key, URL\n     */\n    JSONSearchProvider.supportedParameters = [\n         /*, {\n            name: JSONSearchProvider.API_KEY_PARAM,\n            description: \"The API Key\",\n            value: undefined,\n            required: true\n        }*/,\n        {\n            name: JSONSearchProvider.ID_FIELD_PARAM,\n            description: \"The field that uniquely identifies a given result\",\n            value: \"emailid\",\n            required: true\n        }, {\n            name: JSONSearchProvider.SEARCH_FIELDS,\n            description: \"The fields to search when running a query (comma delimited)\",\n            value: \"body\",\n            required: false\n        }];\n    return JSONSearchProvider;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = JSONSearchProvider;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/freetext/providers/JSONSearchProvider.ts\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/freetext/providers/JSONSearchProvider.ts?");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("var map = {\n\t\"./AzureSearchProvider.ts\": 9,\n\t\"./ElasticSearchSearchProvider.ts\": 10,\n\t\"./ISearchProvider.ts\": 11,\n\t\"./JSONSearchProvider.ts\": 12\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 14;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visuals/freetext/providers \\.ts$\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./visuals/freetext/providers_\\.ts$?");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_15__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jQuery\"\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%22jQuery%22?");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("/* (ignored) */\n\n/*****************\n ** WEBPACK FOOTER\n ** vertx (ignored)\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///vertx_(ignored)?");

/***/ }
/******/ ])
});
;